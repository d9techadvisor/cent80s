<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cent80s v1.5</title>
  <style>
    html,body{margin:0;height:100%;background:#111;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #wrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:10px}
    canvas{background:#000;box-shadow:0 0 0 2px #333 inset, 0 8px 30px #000}
    #hud{display:flex;gap:16px;flex-wrap:wrap;align-items:center;font-weight:600}
    button{background:#222;color:#eee;border:1px solid #444;border-radius:8px;padding:6px 10px;cursor:pointer}
    button:hover{background:#2a2a2a}
    .toggle.on{border-color:#6c6}
    .toggle.off{opacity:.6;border-color:#555}
  </style>
</head>
<body>
  <div id="wrap">
    <div id="hud">
      <div>Score: <span id="score">0</span></div>
      <div>Lives: <span id="lives">3</span></div>
      <div>Level: <span id="level">1</span></div>
      <button id="reset">Reset</button>
      <button id="toggleMusic" class="toggle on">Music: On</button>
      <button id="toggleSfx" class="toggle on">SFX: On</button>
    </div>
    <canvas id="game" width="480" height="640"></canvas>
    <div style="opacity:.7;font-size:12px">Arrows OR WASD to move • Space Bar to shoot</div>
  </div>

<script>
// v1.0 JavaScript game logic (original working version with player–mushroom collision, working audio, and autofire)
(function() {
  // --- Canvas & HUD ---
  const VERSION = '1.5';
  document.title = 'Cent80s v' + VERSION;
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const grid = 16;
  const playHeight = H * 0.8;
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const levelEl = document.getElementById('level');
  const resetBtn = document.getElementById('reset');
  const toggleMusicBtn = document.getElementById('toggleMusic');
  const toggleSfxBtn = document.getElementById('toggleSfx');

  // --- Error overlay ---
  let crashedMsg = null;
  function showError(msg){ crashedMsg = String(msg||'Error'); }
  window.addEventListener('error', e=> showError(e.message||'Script error'));
  window.addEventListener('unhandledrejection', e=> showError((e.reason&&e.reason.message)||e.reason||'Promise error'));

  // --- WebAudio (music + SFX) ---
  let AC=null, masterGain, musicGain, sfxGain, musicTimer=null;
  let musicOn=true, sfxOn=true;
  function ensureAudio(){
    if(AC) return;
    AC = new (window.AudioContext||window.webkitAudioContext)();
    masterGain = AC.createGain(); masterGain.gain.value = 0.8; masterGain.connect(AC.destination);
    musicGain = AC.createGain(); musicGain.gain.value = 0.35; musicGain.connect(masterGain);
    sfxGain   = AC.createGain(); sfxGain.gain.value   = 0.9;  sfxGain.connect(masterGain);
  }
  function setToggleStyle(btn,on){
    btn.classList.toggle('on',on);
    btn.classList.toggle('off',!on);
    btn.textContent = (btn===toggleMusicBtn?'Music: ':'SFX: ') + (on?'On':'Off');
  }
  setToggleStyle(toggleMusicBtn, musicOn);
  setToggleStyle(toggleSfxBtn, sfxOn);
  toggleMusicBtn.onclick = ()=>{ musicOn=!musicOn; setToggleStyle(toggleMusicBtn,musicOn); if(musicGain) musicGain.gain.value = musicOn?0.35:0; };
  toggleSfxBtn.onclick   = ()=>{ sfxOn=!sfxOn;   setToggleStyle(toggleSfxBtn,  sfxOn);   if(sfxGain)   sfxGain.gain.value   = sfxOn?0.9:0; };
  function armAudio(){ ensureAudio(); if(AC.state==='suspended') AC.resume(); if(musicOn && !musicTimer) startMusic(); }
  window.addEventListener('pointerdown', armAudio);
  window.addEventListener('keydown', armAudio);

  // --- SFX helpers ---
  function envNote({freq=440, type='square', gain=0.5, attack=0.005, decay=0.08, sustain=0.15, release=0.08, dur=0.18, out=sfxGain}){
    if(!AC) return; const t0 = AC.currentTime;
    const osc = AC.createOscillator(); osc.type = type; osc.frequency.value = freq;
    const g = AC.createGain(); g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(gain, t0+attack);
    g.gain.linearRampToValueAtTime(gain*sustain, t0+attack+decay);
    g.gain.setValueAtTime(gain*sustain, t0+dur);
    g.gain.linearRampToValueAtTime(0.0001, t0+dur+release);
    osc.connect(g); g.connect(out);
    osc.start(t0); osc.stop(t0+dur+release+0.02);
  }
  function noiseHit({gain=0.35, dur=0.14, out=sfxGain}){
    if(!AC) return; const buffer = AC.createBuffer(1, AC.sampleRate * dur, AC.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * Math.exp(-i/data.length*4);
    const src = AC.createBufferSource(); src.buffer = buffer;
    const g = AC.createGain(); g.gain.value = gain; src.connect(g); g.connect(out); src.start();
  }
  function sfxShoot(){ if(!AC||!sfxOn) return; envNote({freq:520,type:'square',gain:0.4,attack:0.002,decay:0.05,sustain:0.2,release:0.06,dur:0.12}); envNote({freq:880,type:'triangle',gain:0.25,attack:0.002,decay:0.06,sustain:0.0,release:0.06,dur:0.09}); }
  function sfxHit(){ if(!AC||!sfxOn) return; envNote({freq:220,type:'sawtooth',gain:0.5,attack:0.003,decay:0.07,sustain:0.0,release:0.05,dur:0.08}); noiseHit({gain:0.25,dur:0.08}); }
  function sfxThud(){ if(!AC||!sfxOn) return; envNote({freq:140,type:'sine',gain:0.6,attack:0.003,decay:0.08,sustain:0.0,release:0.08,dur:0.10}); }
  function sfxSpider(){ if(!AC||!sfxOn) return; envNote({freq:300,type:'triangle',gain:0.4,attack:0.002,decay:0.08,sustain:0,release:0.07,dur:0.1}); noiseHit({gain:0.18,dur:0.06}); }
  function sfxDeath(){
    if(!AC||!sfxOn) return;
    const t = AC.currentTime;

    // Main tone
    const osc = AC.createOscillator();
    osc.type = 'square';

    // Vibrato (warble): low-frequency sine modulating frequency
    const lfo = AC.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.value = 7; // Hz warble rate
    const lfoGain = AC.createGain();
    lfoGain.gain.value = 25; // vibrato depth in Hz
    lfo.connect(lfoGain);
    lfoGain.connect(osc.frequency);

    // Amplitude envelope
    const g = AC.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.7, t+0.03);
    g.gain.exponentialRampToValueAtTime(0.0001, t+1.3);

    // Pitch glide down
    osc.frequency.setValueAtTime(700, t);
    // Exponential glide gives a natural fall; stops around 120 Hz
    osc.frequency.exponentialRampToValueAtTime(120, t+1.2);

    osc.connect(g); g.connect(sfxGain);

    // Optional noise tail for texture
    const noiseDur = 0.25;
    const buf = AC.createBuffer(1, AC.sampleRate * noiseDur, AC.sampleRate);
    const data = buf.getChannelData(0);
    for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * Math.exp(-i/data.length*3);
    const noise = AC.createBufferSource(); noise.buffer = buf;
    const ng = AC.createGain(); ng.gain.setValueAtTime(0.0001, t+0.9);
    ng.gain.exponentialRampToValueAtTime(0.18, t+0.95);
    ng.gain.exponentialRampToValueAtTime(0.0001, t+1.3);
    noise.connect(ng); ng.connect(sfxGain);

    osc.start(t);
    lfo.start(t);
    noise.start(t+0.9);

    osc.stop(t+1.35);
    lfo.stop(t+1.35);
    noise.stop(t+1.35);
  }
  // --- Music ---
  const arp=[0,7,12,7, 0,7,10,7];
  function musicTempoMs(level){ return level < 3 ? 180 : 180 / (1 + 0.05 * (level - 2)); }
  function musicBaseHz(level){ return 220 * (level < 3 ? 1 : 1 + 0.02 * (level - 2)); }
  function startMusic(){
    if(!AC) return;
    if(musicTimer){ clearInterval(musicTimer); musicTimer=null; }
    if (musicGain) musicGain.gain.value = musicOn ? 0.35 : 0;
    let i=0;
    const stepMs=musicTempoMs(level);
    const base=musicBaseHz(level);
    musicTimer=setInterval(()=>{
      if(!musicOn) return;
      const n=arp[i%arp.length];
      i++;
      envNote({freq: base*Math.pow(2,n/12), type:'triangle', gain:0.22, attack:0.005, decay:0.1, sustain:0.0, release:0.08, dur:stepMs/1000*0.8, out: musicGain});
    }, stepMs);
  }

  function stopMusic(){
    if(musicTimer){ clearInterval(musicTimer); musicTimer = null; }
    if(AC && musicGain){
      try {
        const t = AC.currentTime;
        musicGain.gain.cancelScheduledValues(t);
        musicGain.gain.setValueAtTime(musicGain.gain.value, t);
        // quick fade out
        musicGain.gain.exponentialRampToValueAtTime(0.0001, t + 0.3);
      } catch(e) { /* no-op */ }
    }
  }

  // --- Game Over motif (Beethoven V: da-da-da-DAAA) ---
  function toneAt(tStart, freq, dur, type='square', gain=0.6){
    if(!AC) ensureAudio();
    const osc = AC.createOscillator();
    const g = AC.createGain();
    osc.type = type; osc.frequency.value = freq;
    g.gain.setValueAtTime(0.0001, tStart);
    g.gain.exponentialRampToValueAtTime(gain, tStart+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, tStart+dur);
    osc.connect(g); g.connect(sfxGain || masterGain);
    osc.start(tStart); osc.stop(tStart+dur+0.02);
  }

  let gameOverMotifPlayed = false;
  function playGameOverMotif(){
    if(gameOverMotifPlayed) return;
    ensureAudio();
    gameOverMotifPlayed = true;
    const t0 = AC.currentTime + 0.02;
    // G4, G4, G4, Eb4 (approx 392, 392, 392, 311 Hz)
    const seq = [
      {f:392.00, d:0.18},
      {f:392.00, d:0.18},
      {f:392.00, d:0.18},
      {f:311.13, d:0.60}
    ];
    let t = t0;
    for(const n of seq){ toneAt(t, n.f, n.d, 'square', 0.7); t += n.d + 0.08; }
  }

  // --- Game State ---
  let keys=new Set(), bullets=[], mushrooms=[], centipede=[], spiders=[];
  let screenFlash = 0;
  let spiderTimer=0, spiderDelay=0;
  let player, score, displayScore, lives, level, gameOver, waveCleared, playerDead, deathTimer;
  let invincible = false, invincibleTimer = 0;
  let lastTime=0, acc=0, step=1000/60;
  let popups=[];
  const randInt=(min,max)=>Math.floor(Math.random()*(max-min+1))+min;
  const rand=(min,max)=>Math.random()*(max-min)+min;
  function countMushrooms(){ let total=0, perm=0; for(const m of mushrooms){ total++; if(m.perm) perm++; } return {total,perm}; }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function balancePermanent(batch, target=0.20){ const {total,perm}=countMushrooms(); const totalAfter=total+batch.length; if(totalAfter<=0) return; let need=Math.round(target*totalAfter - perm); need=Math.max(0, Math.min(need, batch.length)); const idx=[...batch.keys()]; shuffle(idx); for(let k=0;k<batch.length;k++){ batch[idx[k]].perm = k < need; } }
  function spiderDelayFor(level){ const max=Math.max(9 - level*0.6, 5.0); const min=Math.max(6 - level*0.5, 3.5); return rand(min,max); }
  function makePlayer(){ return {x:W/2, y:H-3*grid, w:20, h:18, speed:220, fireCD:0}; }
  function makeSegment(x,y,dir,isHead=false){ return {x,y,dir,isHead,alive:true}; }
  function spawnMushrooms(count){ mushrooms=[]; const batch=[]; for(let i=0;i<count;i++){ const gx=randInt(0,(W/grid)-1); const gy=randInt(2,Math.floor((H/grid)-6)); if(Math.random()<0.1) continue; batch.push({x:gx*grid+grid/2, y:gy*grid+grid/2, hp:3, perm:false}); } balancePermanent(batch,0.20); mushrooms.push(...batch); }
  function buildCentipede(len){ centipede=[]; const y=grid/2; for(let i=0;i<len;i++){ const x=(W-grid/2)-i*grid; centipede.push(makeSegment(x,y,-1,i===0)); } }
  function spawnSpider(){ const side=Math.random()<0.5?'L':'R'; const y=rand(playHeight+grid*1.5, H-grid*1.5); const x=(side==='L')?grid/2:W-grid/2; const scale=1 + 0.05*(level-1); const speed=(rand(90,140)+level*4)*scale; const vx=(side==='L'?1:-1)*speed; const vy=rand(-60,60)*scale; spiders.push({x,y,vx,vy,r:grid*0.6,alive:true}); }
  function start(resetAll=false){ if(resetAll){ score=0; lives=3; level=1; } gameOver=false; waveCleared=false; playerDead=false; deathTimer=0; gameOverMotifPlayed = false; player=makePlayer(); bullets=[]; spiders=[]; popups=[]; spiderTimer=0; spiderDelay=spiderDelayFor(level); displayScore=score; spawnMushrooms(28+level*4); buildCentipede(Math.min(12+level*2,24)); startMusic(); updateHUD(); }
  function updateHUD(){ scoreEl.textContent=displayScore|0; livesEl.textContent=lives|0; levelEl.textContent=level|0; }

  // --- Input ---
  window.addEventListener('keydown', e=>{ keys.add(e.key.toLowerCase()); if(e.key===' ') e.preventDefault(); });
  window.addEventListener('keyup', e=> keys.delete(e.key.toLowerCase()));
  function shoot(){ bullets.push({x:player.x, y:player.y-player.h/2, vy:-420}); sfxShoot(); }
  function collide(a,b,rad){ const dx=a.x-b.x, dy=a.y-b.y; return (dx*dx+dy*dy) <= (rad*rad); }

  // --- Update ---
  function update(dt){
    if(gameOver) return;
    if (playerDead) {
      deathTimer -= dt;
      if (deathTimer <= 0) {
        lives--; updateHUD();
        if (lives <= 0) { gameOver = true; stopMusic(); playGameOverMotif(); return; }
        playerDead = false; player = makePlayer(); bullets = [];
        invincible = true;
        invincibleTimer = 2.0;
      }
      return;
    }
    if (invincible) {
      invincibleTimer -= dt;
      if (invincibleTimer <= 0) {
        invincible = false;
        invincibleTimer = 0;
      }
    }
    if (screenFlash > 0) screenFlash = Math.max(0, screenFlash - dt);
    const left=keys.has('arrowleft')||keys.has('a');
    const right=keys.has('arrowright')||keys.has('d');
    const up=keys.has('arrowup')||keys.has('w');
    const down=keys.has('arrowdown')||keys.has('s');
    const fire=keys.has(' ')||keys.has('enter');
    let dx = (right?1:0) - (left?1:0);
    let dy = (down?1:0) - (up?1:0);
    if (dx && dy) { const inv=Math.SQRT1_2; dx*=inv; dy*=inv; }
    let nextX = player.x + dx * player.speed * dt;
    let nextY = player.y + dy * player.speed * dt;
    // --- Mushrooms block player movement (axis-separated) ---
    const mushR = grid*0.45;
    const pw = player.w/2, ph = player.h/2;
    // X sweep
    if (dx !== 0){
      for (const m of mushrooms){
        const nearY = Math.abs(player.y - m.y) < (ph + mushR);
        const willHitX = Math.abs(nextX - m.x) < (pw + mushR);
        if (nearY && willHitX){ nextX = player.x; break; }
      }
    }
    // Y sweep
    if (dy !== 0){
      for (const m of mushrooms){
        const nearX = Math.abs(nextX - m.x) < (pw + mushR);
        const willHitY = Math.abs(nextY - m.y) < (ph + mushR);
        if (nearX && willHitY){ nextY = player.y; break; }
      }
    }
    player.x = nextX;
    player.y = nextY;
    player.x = Math.max(grid/2, Math.min(W-grid/2, player.x));
    player.y = Math.max(playHeight, Math.min(H-grid/2, player.y));
    // --- Firing: autofire ---
    player.fireCD = Math.max(0, player.fireCD - dt);
    if (fire && player.fireCD === 0){ shoot(); player.fireCD = 0.16; }
    // --- Score animation ---
    if (displayScore < score) {
      const step = Math.max(1, Math.floor((score - displayScore) * 0.2));
      displayScore = Math.min(score, displayScore + step);
      scoreEl.textContent = displayScore|0;
    }
    bullets.forEach(b=> b.y += b.vy*dt);
    bullets = bullets.filter(b=> b.y>-20);
    // --- Centipede movement ---
    const base = 70 + Math.min(level*10, 100);
    const speed = base * (1 + 0.05 * (level - 1));
    for(let i=0;i<centipede.length;i++){
      const s=centipede[i]; if(!s.alive) continue; s.x += s.dir*speed*dt;
      const hitWall=(s.x<grid/2)||(s.x>W-grid/2); let hitMush=false;
      for(const m of mushrooms){ if(collide(s,m,grid*0.8)){ hitMush=true; break; } }
      if(hitWall||hitMush){ s.y += grid; s.dir *= -1; s.x = Math.max(grid/2, Math.min(W-grid/2, s.x)); }
      if (s.y > playHeight) {
        if (!playerDead) {
          sfxDeath();
          screenFlash = 0.60; // doubled duration
          lives--; updateHUD();
          if (lives <= 0) {
            gameOver = true;
            stopMusic();
            playGameOverMotif();
          } else {
            start(false);
          }
        }
        return;
      }
    }
    // --- Spiders ---
    spiderTimer += dt;
    const want = Math.min(1 + Math.floor(level/5), 3);
    if (spiders.filter(s=>s.alive).length < want && spiderTimer >= spiderDelay){ spawnSpider(); spiderTimer = 0; spiderDelay = spiderDelayFor(level); }
    for(const sp of spiders){
      if(!sp.alive) continue;
      sp.x += sp.vx*dt; sp.y += sp.vy*dt;
      const minY=playHeight+grid, maxY=H-grid*1.2;
      if(sp.x<grid/2){ sp.x=grid/2; sp.vx*=-1; }
      if(sp.x>W-grid/2){ sp.x=W-grid/2; sp.vx*=-1; }
      if(sp.y<minY){ sp.y=minY; sp.vy*=-1; }
      if(sp.y>maxY){ sp.y=maxY; sp.vy*=-1; }
      for(const m of mushrooms){ if(collide(sp,m,sp.r) && !m.perm) m.dead=true; }
      if(!invincible && !playerDead && collide(sp,player,sp.r)){
        sfxDeath();
        playerDead = true;
        deathTimer = 1.0;
        return;
      }
    }
    mushrooms = mushrooms.filter(m=>!m.dead);
    // --- Bullet vs mushrooms ---
    for(const b of bullets){ for(const m of mushrooms){ if(collide(b,m,grid*0.6)){ b.y=-9999; sfxThud(); if(!m.perm){ m.hp--; if(m.hp<=0){ score+=1; popups.push({x:m.x,y:m.y,txt:'+1',ttl:0.8,vy:-30}); m.dead=true; } } } } }
    mushrooms = mushrooms.filter(m=>!m.dead);
    // --- Bullet vs centipede ---
    for(const b of bullets){
      for(let i=0;i<centipede.length;i++){
        const s=centipede[i]; if(!s.alive) continue;
        if(collide(b,s,grid*0.6)){
          s.alive=false; b.y=-9999; score+=10; popups.push({x:s.x,y:s.y,txt:'+10',ttl:0.8,vy:-30}); sfxHit();
          const {total,perm} = countMushrooms(); const target=0.20; const makePerm = (perm/(total||1)) < target;
          mushrooms.push({x:s.x,y:s.y,hp:3,perm:makePerm});
          for(let j=i+1;j<centipede.length;j++){ if(centipede[j].alive){ centipede[j].isHead=true; break; } }
          break;
        }
      }
    }
    // Player collision with centipede segments (only if not invincible and not dead)
    if (!invincible && !playerDead) {
      for (let i = 0; i < centipede.length; i++) {
        const s = centipede[i];
        if (!s.alive) continue;
        if (collide(player, s, grid*0.6)) {
          sfxDeath();
          playerDead = true;
          deathTimer = 1.0;
          return;
        }
      }
    }
    // --- Bullet vs spiders ---
    for(const b of bullets){ for(const sp of spiders){ if(!sp.alive) continue; if(collide(b,sp,grid*0.6)){ sp.alive=false; b.y=-9999; score+=30; popups.push({x:sp.x,y:sp.y,txt:'+30',ttl:0.8,vy:-30}); sfxSpider(); } } }
    bullets = bullets.filter(b=> b.y>-20);
    if(centipede.every(s=>!s.alive)){ waveCleared=true; level++; score+=100; popups.push({x:W/2,y:playHeight-12,txt:'+100',ttl:1.2,vy:-20}); start(false); }
    for(const p of popups){ p.y += p.vy*dt; p.ttl -= dt; } popups = popups.filter(p=> p.ttl>0);
  }
  // --- Helpers: drawRock (perm) and drawMushroom (regular) ---
  function _rng(seed){ return function(){ seed = (seed*1664525+1013904223)>>>0; return (seed & 0xfffffff) / 0x10000000; }; }

  function drawRock(ctx, x, y, r, seed){
    const rand = _rng((seed>>>0) || 1);
    const n = 10; // vertices
    const pts = [];
    for(let i=0;i<n;i++){
      const a = (i/n)*Math.PI*2 + (rand()-0.5)*0.15; // slight angle jitter
      const rr = r*(0.8 + rand()*0.35);              // bumpy radius
      pts.push([x + Math.cos(a)*rr, y + Math.sin(a)*rr]);
    }
    // Fill
    ctx.save();
    ctx.fillStyle = '#7a6d5c'; // rock base
    ctx.beginPath();
    ctx.moveTo(pts[0][0], pts[0][1]);
    for(let i=1;i<n;i++) ctx.lineTo(pts[i][0], pts[i][1]);
    ctx.closePath();
    ctx.fill();
    // Edge highlight + shadow
    ctx.strokeStyle = '#4f453a';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#b3a693'; // highlight
    ctx.beginPath();
    ctx.arc(x - r*0.2, y - r*0.2, r*0.65, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawMushroom(ctx, x, y, r, hp, seed){
    const rand = _rng(((x*73856093) ^ (y*19349663))>>>0);
    // Stem
    const stemW = Math.max(4, r*0.55);
    const stemH = r*0.7;
    ctx.fillStyle = '#e6d7b5';
    ctx.fillRect(x - stemW/2, y, stemW, stemH);
    // Cap (semi-circle)
    ctx.fillStyle = '#34c759';
    ctx.beginPath();
    ctx.arc(x, y, r, Math.PI, 0);
    ctx.quadraticCurveTo(x + r*0.9, y + r*0.35, x, y + r*0.35);
    ctx.quadraticCurveTo(x - r*0.9, y + r*0.35, x - r, y);
    ctx.closePath();
    ctx.fill();
    // Cap outline
    ctx.strokeStyle = '#2f7a36';
    ctx.lineWidth = 1;
    ctx.stroke();
    // Dots — per‑mushroom unique pattern (3–5), deterministic & non‑overlapping
    {
      const dotR = 2.4;                 // dot radius
      let   pad  = 0.3;                 // smaller pad so more can fit
      const dotColor = '#2f7a36';
      const dotRand = _rng((((x*73856093) ^ (y*19349663)) + 0x9e3779b9) >>> 0);
      const targetCount = 3 + Math.floor(dotRand() * 3); // 3..5 dots
      const placed = [];
      ctx.fillStyle = dotColor;

      for (let n = 0; n < targetCount; n++) {
        let placedThis = false;
        // Adaptive min distance (relaxes if placement keeps failing)
        const baseMinD = dotR*2 + pad;
        for (let tries = 0; tries < 30 && !placedThis; tries++) {
          // Widened region: broader angles and radius band on the cap
          const a  = Math.PI * (0.15 + dotRand() * 0.70);   // ~0.15π..0.85π
          const dr = r * (0.20 + dotRand() * 0.55);         // 0.20r..0.75r
          const dx = x + Math.cos(a) * dr * 0.9;
          const dy = y - Math.sin(a) * dr * 0.8;

          // Soften spacing after many tries to encourage placement
          let minD = baseMinD;
          if (tries >= 20) minD *= 0.85; else if (tries >= 10) minD *= 0.93;
          const minD2 = minD*minD;

          let ok = true;
          for (let i = 0; i < placed.length; i++) {
            const px = placed[i][0], py = placed[i][1];
            const ddx = dx - px, ddy = dy - py;
            if (ddx*ddx + ddy*ddy < minD2) { ok = false; break; }
          }
          if (ok) {
            placed.push([dx, dy]);
            ctx.beginPath();
            ctx.arc(dx, dy, dotR, 0, Math.PI * 2);
            ctx.fill();
            placedThis = true;
          }
        }
        // If not placed after all tries, skip; determinism retained
      }
    }

    // Damage stages based on HP (3 = full, 2 = light damage, 1 = heavy damage)
    if (hp < 3) {
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.fillStyle = 'rgba(0,0,0,1)';
      if (hp === 2) {
        // Small bite mark on upper right
        ctx.beginPath();
        ctx.arc(x + r*0.4, y - r*0.4, r*0.35, 0, Math.PI*2);
        ctx.fill();
      } else if (hp === 1) {
        // Larger chunk missing on right side
        ctx.beginPath();
        ctx.arc(x + r*0.35, y - r*0.1, r*0.55, 0, Math.PI*2);
        ctx.fill();
        // And small extra bite on left
        ctx.beginPath();
        ctx.arc(x - r*0.45, y - r*0.35, r*0.3, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();

      // Draw jagged edge over damage for effect
      ctx.save();
      ctx.strokeStyle = '#b32222';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(x, y, r, Math.PI*0.1, Math.PI*0.4);
      ctx.stroke();
      ctx.restore();
    }

    // Slight shadow under cap
    ctx.globalAlpha = 0.25; ctx.fillStyle = '#000';
    ctx.beginPath(); ctx.ellipse(x, y + r*0.35, r*0.7, r*0.18, 0, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;

    // Highlight
    let grad = ctx.createRadialGradient(x - r*0.3, y - r*0.3, r*0.1, x, y, r);
    grad.addColorStop(0, 'rgba(180,255,180,0.18)');
    grad.addColorStop(1, 'rgba(255,255,200,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(x, y, r, Math.PI, 0, false);
    ctx.quadraticCurveTo(x + r*0.9, y + r*0.35, x, y + r*0.35);
    ctx.quadraticCurveTo(x - r*0.9, y + r*0.35, x - r, y);
    ctx.closePath();
    ctx.fill();
  }

  // --- Draw ---
  function draw(){
    if(crashedMsg){ ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='bold 18px system-ui'; ctx.fillText('⚠️ Script error', W/2, H/2-10); ctx.font='12px system-ui'; ctx.fillText(String(crashedMsg), W/2, H/2+12); return; }
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 0.15; ctx.strokeStyle='#222';
    for(let x=0;x<=W;x+=grid){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<=H;y+=grid){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.globalAlpha = 1;
    for (const m of mushrooms) {
      if (m.perm) {
        // Permanent obstacles: draw as rocks/asteroids
        drawRock(ctx, m.x, m.y, grid*0.72, ((m.x*2654435761) ^ (m.y*1597334677))>>>0);
      } else {
        // Regular mushrooms: classic cap + stem
        drawMushroom(ctx, m.x, m.y, grid*0.5625, m.hp);
      }
    }
    for(const s of centipede){ if(!s.alive) continue; ctx.fillStyle=s.isHead?'#f55':'#fa0'; ctx.beginPath(); ctx.arc(s.x,s.y,grid*0.45,0,Math.PI*2); ctx.fill(); if(s.isHead){ ctx.fillStyle='#fff'; ctx.fillRect(s.x-3,s.y-2,2,2); ctx.fillRect(s.x+1,s.y-2,2,2); } }
    if (!playerDead) {
      // Wedge ship with fins & cockpit; glow; flicker when invincible
      ctx.save();
      ctx.shadowColor = '#6bf';
      ctx.shadowBlur = 10;

      // Flicker when invincible
      let alpha = 1;
      if (invincible) {
        alpha = Math.abs(Math.sin(performance.now()*0.02)) > 0.5 ? 0.35 : 1;
      }
      ctx.globalAlpha = alpha;

      // Wedge body
      ctx.fillStyle = '#4af';
      ctx.beginPath();
      ctx.moveTo(player.x,    player.y-8);   // nose
      ctx.lineTo(player.x-7,  player.y+8);   // left tail
      ctx.lineTo(player.x+7,  player.y+8);   // right tail
      ctx.closePath();
      ctx.fill();

      // Outline
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.stroke();

      // Side fins
      ctx.fillStyle = '#3c8ee6';
      ctx.beginPath();
      ctx.moveTo(player.x-7, player.y+2); ctx.lineTo(player.x-13, player.y+8); ctx.lineTo(player.x-6, player.y+10); ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(player.x+7, player.y+2); ctx.lineTo(player.x+13, player.y+8); ctx.lineTo(player.x+6, player.y+10); ctx.closePath();
      ctx.fill();

      // Cockpit window
      ctx.fillStyle = '#d2f0ff';
      ctx.fillRect(player.x-3.5, player.y-4, 7, 4);

      // Headlights (subtle forward beams ~1.5× ship length)
      const noseX = player.x;
      const noseY = player.y - 8;
      const beamLen = 24; // approx 1.5x current ship height

      // Center soft cone
      let grad = ctx.createLinearGradient(noseX, noseY, noseX, noseY - beamLen);
      grad.addColorStop(0, 'rgba(210,240,255,0.30)');
      grad.addColorStop(1, 'rgba(210,240,255,0.00)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(noseX, noseY);
      ctx.lineTo(noseX - 6, noseY - beamLen);
      ctx.lineTo(noseX + 6, noseY - beamLen);
      ctx.closePath();
      ctx.fill();

      // Slight left/right accent beams for shape
      let gradL = ctx.createLinearGradient(noseX-2, noseY, noseX-6, noseY - beamLen);
      gradL.addColorStop(0, 'rgba(210,240,255,0.18)');
      gradL.addColorStop(1, 'rgba(210,240,255,0.00)');
      ctx.fillStyle = gradL;
      ctx.beginPath();
      ctx.moveTo(noseX-2, noseY-1);
      ctx.lineTo(noseX-7, noseY - beamLen);
      ctx.lineTo(noseX-3, noseY - beamLen);
      ctx.closePath();
      ctx.fill();

      let gradR = ctx.createLinearGradient(noseX+2, noseY, noseX+6, noseY - beamLen);
      gradR.addColorStop(0, 'rgba(210,240,255,0.18)');
      gradR.addColorStop(1, 'rgba(210,240,255,0.00)');
      ctx.fillStyle = gradR;
      ctx.beginPath();
      ctx.moveTo(noseX+2, noseY-1);
      ctx.lineTo(noseX+7, noseY - beamLen);
      ctx.lineTo(noseX+3, noseY - beamLen);
      ctx.closePath();
      ctx.fill();

      // Shield ring during invincibility
      if (invincible) {
        ctx.globalAlpha = 0.6;
        ctx.shadowBlur = 15;
        ctx.strokeStyle = '#8cf';
        const r = 12 + Math.sin(performance.now()*0.02)*2;
        ctx.beginPath();
        ctx.arc(player.x, player.y, r, 0, Math.PI*2);
        ctx.stroke();
      }

      ctx.restore();
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    } else {
      // Shrink the player rectangle while dead (no red X)
      const alpha = 0.7 + 0.3*Math.sin(performance.now()*0.02);
      const scale = Math.max(0.2, deathTimer);
      const pw = player.w * scale;
      const ph = player.h * scale;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#777';
      ctx.fillRect(player.x-pw/2, player.y-ph/2, pw, ph);
      ctx.restore();
    }
    ctx.strokeStyle='#333'; ctx.beginPath(); ctx.moveTo(0,playHeight); ctx.lineTo(W,playHeight); ctx.stroke();
    ctx.fillStyle='#fff'; for(const b of bullets){ ctx.fillRect(b.x-1,b.y-6,2,8); }
    for(const sp of spiders){ if(!sp.alive) continue; const r=sp.r; ctx.fillStyle='#221f2a'; ctx.beginPath(); ctx.arc(sp.x, sp.y, r, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#3a3347'; ctx.beginPath(); ctx.arc(sp.x + r*0.55, sp.y, r*0.55, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle='#6b5a87'; ctx.lineWidth=1; for(let side=-1; side<=1; side+=2){ for(let i=0;i<4;i++){ const t=(i-1.5)*0.5; const x1=sp.x + side*r*0.6; const y1=sp.y + t*r*0.5; const x2=sp.x + side*r*1.4; const y2=sp.y + t*r*0.6 + (i%2?3:-3); ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); } } }
    ctx.textAlign='center'; ctx.font='bold 14px system-ui';
    for(const p of popups){ const a = Math.max(0, Math.min(1, p.ttl/0.8)); ctx.globalAlpha = a; ctx.fillStyle = '#ffd54a'; ctx.fillText(p.txt, p.x, p.y); }
    ctx.globalAlpha = 1;
    // Brief screen flash on death
    if (screenFlash > 0) {
      const a = Math.min(1, screenFlash / 0.60);
      ctx.fillStyle = `rgba(255,64,64,${0.45 * a})`;
      ctx.fillRect(0, 0, W, H);
    }
    if(gameOver){ ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='bold 28px system-ui'; ctx.fillText('Game Over', W/2, H/2-8); ctx.font='14px system-ui'; ctx.fillText('Click Reset to play again', W/2, H/2+18); }
  }
  // --- Loop ---
  function loop(ts){ if(!lastTime) lastTime=ts; let dt=ts-lastTime; lastTime=ts; acc+=dt; while(acc>=step){ try{ update(step/1000); }catch(err){ showError(err); break; } acc-=step; } try{ draw(); }catch(err){ showError(err); } requestAnimationFrame(loop); }
  // --- Self-test & init ---
  function selfTest(){ const ok=(n,c)=>console[(c?'log':'error')]((c?'✅ ':'❌ ')+n); ok('Canvas context', !!ctx); ok('RAF exists', !!window.requestAnimationFrame); ok('HUD present', !!resetBtn && !!toggleMusicBtn && !!toggleSfxBtn); }
  window.gameDebug = { selfTest, start };
  resetBtn.onclick = ()=> start(true);
  start(true);
  selfTest();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
