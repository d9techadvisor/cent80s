<!-- test --/>

<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Centipede — v0.9 (autofire + collision)</title>
  <style>
    html,body{margin:0;height:100%;background:#111;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #wrap{display:flex;flex-direction:column;align-items:center;gap:8px;padding:10px}
    canvas{background:#000;box-shadow:0 0 0 2px #333 inset, 0 8px 30px #000}
    #hud{display:flex;gap:16px;flex-wrap:wrap;align-items:center;font-weight:600}
    button{background:#222;color:#eee;border:1px solid #444;border-radius:8px;padding:6px 10px;cursor:pointer}
    button:hover{background:#2a2a2a}
    .toggle.on{border-color:#6c6}
    .toggle.off{opacity:.6;border-color:#555}
  </style>
</head>
<body>
  <div id="wrap">
    <div id="hud">
      <div>Score: <span id="score">0</span></div>
      <div>Lives: <span id="lives">3</span></div>
      <div>Level: <span id="level">1</span></div>
      <button id="reset">Reset</button>
      <button id="toggleMusic" class="toggle on">Music: On</button>
      <button id="toggleSfx" class="toggle on">SFX: On</button>
    </div>
    <canvas id="game" width="480" height="640"></canvas>
    <div style="opacity:.7;font-size:12px">Arrows/WASD to move • Space to shoot • Click/press once to arm audio</div>
  </div>

<script>
(() => {
  // ------- Canvas & HUD -------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const grid = 16;
  const playHeight = H * 0.8;
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const levelEl = document.getElementById('level');
  const resetBtn = document.getElementById('reset');
  const toggleMusicBtn = document.getElementById('toggleMusic');
  const toggleSfxBtn = document.getElementById('toggleSfx');

  // ------- Error overlay -------
  let crashedMsg = null;
  function showError(msg){ crashedMsg = String(msg||'Error'); }
  window.addEventListener('error', e=> showError(e.message||'Script error'));
  window.addEventListener('unhandledrejection', e=> showError((e.reason&&e.reason.message)||e.reason||'Promise error'));

  // ------- WebAudio (music + SFX) -------
  let AC=null, masterGain, musicGain, sfxGain, musicTimer=null;
  let musicOn=true, sfxOn=true;

  function ensureAudio(){
    if(AC) return;
    AC = new (window.AudioContext||window.webkitAudioContext)();
    masterGain = AC.createGain(); masterGain.gain.value = 0.8; masterGain.connect(AC.destination);
    musicGain = AC.createGain(); musicGain.gain.value = 0.35; musicGain.connect(masterGain);
    sfxGain   = AC.createGain(); sfxGain.gain.value   = 0.9;  sfxGain.connect(masterGain);
  }
  function setToggleStyle(btn,on){
    btn.classList.toggle('on',on);
    btn.classList.toggle('off',!on);
    btn.textContent = (btn===toggleMusicBtn?'Music: ':'SFX: ') + (on?'On':'Off');
  }
  setToggleStyle(toggleMusicBtn, musicOn);
  setToggleStyle(toggleSfxBtn, sfxOn);
  toggleMusicBtn.onclick = ()=>{ musicOn=!musicOn; setToggleStyle(toggleMusicBtn,musicOn); if(musicGain) musicGain.gain.value = musicOn?0.35:0; };
  toggleSfxBtn.onclick   = ()=>{ sfxOn=!sfxOn;   setToggleStyle(toggleSfxBtn,  sfxOn);   if(sfxGain)   sfxGain.gain.value   = sfxOn?0.9:0; };

  function armAudio(){ ensureAudio(); if(AC.state==='suspended') AC.resume(); if(musicOn && !musicTimer) startMusic(); }
  window.addEventListener('pointerdown', armAudio);
  window.addEventListener('keydown', armAudio);

  // Simple synth helpers
  function envNote({freq=440, type='square', gain=0.5, attack=0.005, decay=0.08, sustain=0.15, release=0.08, dur=0.18, out=sfxGain}){
    if(!AC) return; const t0 = AC.currentTime;
    const osc = AC.createOscillator(); osc.type = type; osc.frequency.value = freq;
    const g = AC.createGain(); g.gain.setValueAtTime(0, t0);
    g.gain.linearRampToValueAtTime(gain, t0+attack);
    g.gain.linearRampToValueAtTime(gain*sustain, t0+attack+decay);
    g.gain.setValueAtTime(gain*sustain, t0+dur);
    g.gain.linearRampToValueAtTime(0.0001, t0+dur+release);
    osc.connect(g); g.connect(out);
    osc.start(t0); osc.stop(t0+dur+release+0.02);
  }
  function noiseHit({gain=0.35, dur=0.14, out=sfxGain}){
    if(!AC) return; const buffer = AC.createBuffer(1, AC.sampleRate * dur, AC.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * Math.exp(-i/data.length*4);
    const src = AC.createBufferSource(); src.buffer = buffer;
    const g = AC.createGain(); g.gain.value = gain; src.connect(g); g.connect(out); src.start();
  }

  // Modern retro FX
  function sfxShoot(){ if(!AC||!sfxOn) return; envNote({freq:520,type:'square',gain:0.4,attack:0.002,decay:0.05,sustain:0.2,release:0.06,dur:0.12}); envNote({freq:880,type:'triangle',gain:0.25,attack:0.002,decay:0.06,sustain:0.0,release:0.06,dur:0.09}); }
  function sfxHit(){ if(!AC||!sfxOn) return; envNote({freq:220,type:'sawtooth',gain:0.5,attack:0.003,decay:0.07,sustain:0.0,release:0.05,dur:0.08}); noiseHit({gain:0.25,dur:0.08}); }
  function sfxThud(){ if(!AC||!sfxOn) return; envNote({freq:140,type:'sine',gain:0.6,attack:0.003,decay:0.08,sustain:0.0,release:0.08,dur:0.10}); }
  function sfxSpider(){ if(!AC||!sfxOn) return; envNote({freq:300,type:'triangle',gain:0.4,attack:0.002,decay:0.08,sustain:0,release:0.07,dur:0.1}); noiseHit({gain:0.18,dur:0.06}); }

  // Tiny background arpeggio loop with tempo/pitch scaling by level
  const arp=[0,7,12,7, 0,7,10,7];
  function musicTempoMs(level){ return level < 3 ? 180 : 180 / (1 + 0.05 * (level - 2)); } // +5%/lvl from L3
  function musicBaseHz(level){ return 220 * (level < 3 ? 1 : 1 + 0.02 * (level - 2)); }   // +2%/lvl from L3
  function startMusic(){ if(!AC) return; if(musicTimer){ clearInterval(musicTimer); musicTimer=null; } let i=0; const stepMs=musicTempoMs(level); const base=musicBaseHz(level); musicTimer=setInterval(()=>{ if(!musicOn) return; const n=arp[i%arp.length]; i++; envNote({freq: base*Math.pow(2,n/12), type:'triangle', gain:0.22, attack:0.005, decay:0.1, sustain:0.0, release:0.08, dur:stepMs/1000*0.8, out: musicGain}); }, stepMs); }

  // ------- Game State -------
  let keys=new Set(), bullets=[], mushrooms=[], centipede=[], spiders=[];
  let spiderTimer=0, spiderDelay=0;
  let player, score, displayScore, lives, level, gameOver, waveCleared;
  let lastTime=0, acc=0, step=1000/60;
  let popups=[];

  const randInt=(min,max)=>Math.floor(Math.random()*(max-min+1))+min;
  const rand=(min,max)=>Math.random()*(max-min)+min;

  // --- Permanent mushroom balancing to ~20% visible
  function countMushrooms(){ let total=0, perm=0; for(const m of mushrooms){ total++; if(m.perm) perm++; } return {total,perm}; }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function balancePermanent(batch, target=0.20){ const {total,perm}=countMushrooms(); const totalAfter=total+batch.length; if(totalAfter<=0) return; let need=Math.round(target*totalAfter - perm); need=Math.max(0, Math.min(need, batch.length)); const idx=[...batch.keys()]; shuffle(idx); for(let k=0;k<batch.length;k++){ batch[idx[k]].perm = k < need; } }

  function spiderDelayFor(level){ const max=Math.max(9 - level*0.6, 5.0); const min=Math.max(6 - level*0.5, 3.5); return rand(min,max); }
  function makePlayer(){ return {x:W/2, y:H-3*grid, w:grid, h:grid, speed:220, fireCD:0}; }
  function makeSegment(x,y,dir,isHead=false){ return {x,y,dir,isHead,alive:true}; }
  function spawnMushrooms(count){ mushrooms=[]; const batch=[]; for(let i=0;i<count;i++){ const gx=randInt(0,(W/grid)-1); const gy=randInt(2,Math.floor((H/grid)-6)); if(Math.random()<0.1) continue; batch.push({x:gx*grid+grid/2, y:gy*grid+grid/2, hp:3, perm:false}); } balancePermanent(batch,0.20); mushrooms.push(...batch); }
  function buildCentipede(len){ centipede=[]; const y=grid/2; for(let i=0;i<len;i++){ const x=(W-grid/2)-i*grid; centipede.push(makeSegment(x,y,-1,i===0)); } }
  function spawnSpider(){ const side=Math.random()<0.5?'L':'R'; const y=rand(playHeight+grid*1.5, H-grid*1.5); const x=(side==='L')?grid/2:W-grid/2; const scale=1 + 0.05*(level-1); const speed=(rand(90,140)+level*4)*scale; const vx=(side==='L'?1:-1)*speed; const vy=rand(-60,60)*scale; spiders.push({x,y,vx,vy,r:grid*0.6,alive:true}); }

  function start(resetAll=false){ if(resetAll){ score=0; lives=3; level=1; } gameOver=false; waveCleared=false; player=makePlayer(); bullets=[]; spiders=[]; popups=[]; spiderTimer=0; spiderDelay=spiderDelayFor(level); displayScore=score; spawnMushrooms(28+level*4); buildCentipede(Math.min(12+level*2,24)); startMusic(); updateHUD(); }
  function updateHUD(){ scoreEl.textContent=displayScore|0; livesEl.textContent=lives|0; levelEl.textContent=level|0; }

  // ------- Input -------
  window.addEventListener('keydown', e=>{ keys.add(e.key.toLowerCase()); if(e.key===' ') e.preventDefault(); });
  window.addEventListener('keyup', e=> keys.delete(e.key.toLowerCase()));
  function shoot(){ bullets.push({x:player.x, y:player.y-player.h/2, vy:-420}); sfxShoot(); }
  function collide(a,b,rad){ const dx=a.x-b.x, dy=a.y-b.y; return (dx*dx+dy*dy) <= (rad*rad); }

  // ------- Update -------
  function update(dt){
    if(gameOver) return;
    const left=keys.has('arrowleft')||keys.has('a');
    const right=keys.has('arrowright')||keys.has('d');
    const up=keys.has('arrowup')||keys.has('w');
    const down=keys.has('arrowdown')||keys.has('s');
    const fire=keys.has(' ')||keys.has('enter');

    // Compute intended movement (normalized diagonals)
    let dx = (right?1:0) - (left?1:0);
    let dy = (down?1:0) - (up?1:0);
    if (dx && dy) { const inv=Math.SQRT1_2; dx*=inv; dy*=inv; }

    // Proposed new positions
    let nextX = player.x + dx * player.speed * dt;
    let nextY = player.y + dy * player.speed * dt;

    // Block against mushrooms: axis-separated using mushroom radius vs player half-sizes
    const mushR = grid*0.45;
    const pw = player.w/2, ph = player.h/2;

    // Horizontal sweep
    if (dx !== 0){
      for (const m of mushrooms){
        const nearY = Math.abs(player.y - m.y) < (ph + mushR);
        const willHitX = Math.abs(nextX - m.x) < (pw + mushR);
        if (nearY && willHitX){ nextX = player.x; break; }
      }
    }
    // Vertical sweep
    if (dy !== 0){
      for (const m of mushrooms){
        const nearX = Math.abs(nextX - m.x) < (pw + mushR);
        const willHitY = Math.abs(nextY - m.y) < (ph + mushR);
        if (nearX && willHitY){ nextY = player.y; break; }
      }
    }

    player.x = nextX;
    player.y = nextY;

    // Clamp to player area
    player.x = Math.max(grid/2, Math.min(W-grid/2, player.x));
    player.y = Math.max(playHeight, Math.min(H-grid/2, player.y));

    // Firing: hold to auto-fire (~6/sec)
    player.fireCD = Math.max(0, player.fireCD - dt);
    if (fire && player.fireCD === 0){ shoot(); player.fireCD = 0.16; }

    // Smooth score count-up animation
    if (displayScore < score) {
      const step = Math.max(1, Math.floor((score - displayScore) * 0.2));
      displayScore = Math.min(score, displayScore + step);
      scoreEl.textContent = displayScore|0;
    }

    bullets.forEach(b=> b.y += b.vy*dt);
    bullets = bullets.filter(b=> b.y>-20);

    // centipede (speed +5% per level)
    const base = 70 + Math.min(level*10, 100);
    const speed = base * (1 + 0.05 * (level - 1));
    for(let i=0;i<centipede.length;i++){
      const s=centipede[i]; if(!s.alive) continue; s.x += s.dir*speed*dt;
      const hitWall=(s.x<grid/2)||(s.x>W-grid/2); let hitMush=false;
      for(const m of mushrooms){ if(collide(s,m,grid*0.8)){ hitMush=true; break; } }
      if(hitWall||hitMush){ s.y += grid; s.dir *= -1; s.x = Math.max(grid/2, Math.min(W-grid/2, s.x)); }
      if(s.y > playHeight){ lives--; updateHUD(); if(lives<=0){ gameOver=true; } else start(false); return; }
    }

    // spiders — tuned spawn cadence
    spiderTimer += dt;
    const want = Math.min(1 + Math.floor(level/5), 3);
    if (spiders.filter(s=>s.alive).length < want && spiderTimer >= spiderDelay){ spawnSpider(); spiderTimer = 0; spiderDelay = spiderDelayFor(level); }
    for(const sp of spiders){ if(!sp.alive) continue; sp.x += sp.vx*dt; sp.y += sp.vy*dt; const minY=playHeight+grid, maxY=H-grid*1.2; if(sp.x<grid/2){ sp.x=grid/2; sp.vx*=-1; } if(sp.x>W-grid/2){ sp.x=W-grid/2; sp.vx*=-1; } if(sp.y<minY){ sp.y=minY; sp.vy*=-1; } if(sp.y>maxY){ sp.y=maxY; sp.vy*=-1; } for(const m of mushrooms){ if(collide(sp,m,sp.r) && !m.perm) m.dead=true; } if(collide(sp,player,sp.r)){ lives--; updateHUD(); sfxHit(); if(lives<=0){ gameOver=true; } else start(false); return; } }
    mushrooms = mushrooms.filter(m=>!m.dead);

    // Bullet vs mushrooms (respect permanent)
    for(const b of bullets){ for(const m of mushrooms){ if(collide(b,m,grid*0.6)){ b.y=-9999; sfxThud(); if(!m.perm){ m.hp--; if(m.hp<=0){ score+=1; popups.push({x:m.x,y:m.y,txt:'+1',ttl:0.8,vy:-30}); m.dead=true; } } } } }
    mushrooms = mushrooms.filter(m=>!m.dead);

    // Bullet vs centipede
    for(const b of bullets){ for(let i=0;i<centipede.length;i++){ const s=centipede[i]; if(!s.alive) continue; if(collide(b,s,grid*0.6)){ s.alive=false; b.y=-9999; score+=10; popups.push({x:s.x,y:s.y,txt:'+10',ttl:0.8,vy:-30}); sfxHit();
          // When a segment drops a mush, maintain ~20% perm
          const {total,perm} = countMushrooms(); const target=0.20; const makePerm = (perm/(total||1)) < target;
          mushrooms.push({x:s.x,y:s.y,hp:3,perm:makePerm});
          for(let j=i+1;j<centipede.length;j++){ if(centipede[j].alive){ centipede[j].isHead=true; break; } }
          break; } } }

    // Bullet vs spiders
    for(const b of bullets){ for(const sp of spiders){ if(!sp.alive) continue; if(collide(b,sp,grid*0.6)){ sp.alive=false; b.y=-9999; score+=30; popups.push({x:sp.x,y:sp.y,txt:'+30',ttl:0.8,vy:-30}); sfxSpider(); } } }
    bullets = bullets.filter(b=> b.y>-20);

    if(centipede.every(s=>!s.alive)){ waveCleared=true; level++; score+=100; popups.push({x:W/2,y:playHeight-12,txt:'+100',ttl:1.2,vy:-20}); start(false); }

    // popups update
    for(const p of popups){ p.y += p.vy*dt; p.ttl -= dt; } popups = popups.filter(p=> p.ttl>0);
  }

  // ------- Draw -------
  function draw(){
    if(crashedMsg){ ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='bold 18px system-ui'; ctx.fillText('⚠️ Script error', W/2, H/2-10); ctx.font='12px system-ui'; ctx.fillText(String(crashedMsg), W/2, H/2+12); return; }
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    // grid
    ctx.globalAlpha = 0.15; ctx.strokeStyle='#222';
    for(let x=0;x<=W;x+=grid){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<=H;y+=grid){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.globalAlpha = 1;

    // mushrooms
    for(const m of mushrooms){
      if(m.perm){ // lighter, brighter blue permanent
        ctx.fillStyle='#8cf';
        ctx.beginPath(); ctx.arc(m.x,m.y,grid*0.45,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='#bef'; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(m.x,m.y,grid*0.5,0,Math.PI*2); ctx.stroke();
      } else {
        ctx.fillStyle='#7c4'; ctx.beginPath(); ctx.arc(m.x,m.y,grid*0.45,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='#2a2'; for(let i=0;i<m.hp;i++){ ctx.fillRect(m.x-6+i*6-3, m.y+6, 4,4); }
      }
    }

    // centipede
    for(const s of centipede){ if(!s.alive) continue; ctx.fillStyle=s.isHead?'#f55':'#fa0'; ctx.beginPath(); ctx.arc(s.x,s.y,grid*0.45,0,Math.PI*2); ctx.fill(); if(s.isHead){ ctx.fillStyle='#fff'; ctx.fillRect(s.x-3,s.y-2,2,2); ctx.fillRect(s.x+1,s.y-2,2,2); } }

    // player
    ctx.fillStyle='#4af'; ctx.fillRect(player.x-player.w/2, player.y-player.h/2, player.w, player.h);

    // boundary
    ctx.strokeStyle='#333'; ctx.beginPath(); ctx.moveTo(0,playHeight); ctx.lineTo(W,playHeight); ctx.stroke();

    // bullets
    ctx.fillStyle='#fff'; for(const b of bullets){ ctx.fillRect(b.x-1,b.y-6,2,8); }

    // spiders (abdomen + head + 8 legs)
    for(const sp of spiders){ if(!sp.alive) continue; const r=sp.r; ctx.fillStyle='#221f2a'; ctx.beginPath(); ctx.arc(sp.x, sp.y, r, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#3a3347'; ctx.beginPath(); ctx.arc(sp.x + r*0.55, sp.y, r*0.55, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle='#6b5a87'; ctx.lineWidth=1; for(let side=-1; side<=1; side+=2){ for(let i=0;i<4;i++){ const t=(i-1.5)*0.5; const x1=sp.x + side*r*0.6; const y1=sp.y + t*r*0.5; const x2=sp.x + side*r*1.4; const y2=sp.y + t*r*0.6 + (i%2?3:-3); ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); } } }

    // floating point popups
    ctx.textAlign='center'; ctx.font='bold 14px system-ui';
    for(const p of popups){ const a = Math.max(0, Math.min(1, p.ttl/0.8)); ctx.globalAlpha = a; ctx.fillStyle = '#ffd54a'; ctx.fillText(p.txt, p.x, p.y); }
    ctx.globalAlpha = 1;

    if(gameOver){ ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='bold 28px system-ui'; ctx.fillText('Game Over', W/2, H/2-8); ctx.font='14px system-ui'; ctx.fillText('Click Reset to play again', W/2, H/2+18); }
  }

  // ------- Loop -------
  function loop(ts){ if(!lastTime) lastTime=ts; let dt=ts-lastTime; lastTime=ts; acc+=dt; while(acc>=step){ try{ update(step/1000); }catch(err){ showError(err); break; } acc-=step; } try{ draw(); }catch(err){ showError(err); } requestAnimationFrame(loop); }

  // ------- Self-test & init -------
  function selfTest(){ const ok=(n,c)=>console[(c?'log':'error')]((c?'✅ ':'❌ ')+n); ok('Canvas context', !!ctx); ok('RAF exists', !!window.requestAnimationFrame); ok('HUD present', !!resetBtn && !!toggleMusicBtn && !!toggleSfxBtn); }
  window.gameDebug = { selfTest, start };
  resetBtn.onclick = ()=> start(true);
  start(true);
  selfTest();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
